apiVersion: karpenter.k8s.aws/v1
kind: EC2NodeClass
metadata:
  name: spotvng
spec:
  amiFamily: AL2023
  amiSelectorTerms:
  - id: ami-0cfd8c9a873d73514
  blockDeviceMappings:
  - deviceName: /dev/xvda
    ebs:
      deleteOnTermination: true
      volumeSize: 30Gi
      volumeType: gp3
      encrypted: true
  metadataOptions:
    httpEndpoint: enabled
    httpProtocolIPv6: disabled
    httpPutResponseHopLimit: 2
    httpTokens: optional
  role: KarpenterNodeRole-poc-kafka2
  securityGroupSelectorTerms:
  - id: sg-0e1d856eae7d791ce
  - id: sg-01c69055fd5bc91e5
  subnetSelectorTerms:
  - id: subnet-0d5e644a40aeb6e1d
  - id: subnet-04f139d71de94997e
  tags:
    Name: poc-kafka2-k8s-AmazonLinux2023-Node
    alpha.eksctl.io/cluster-name: poc-kafka2
    app.bancolombia.com.co/application-code: ops0005001
    app.bancolombia.com.co/cost-center: C103500093
    app.bancolombia.com.co/env: qa
    app.bancolombia.com.co/evc_cde: cde-plataformas-y-disponibilidad-ti
    app.bancolombia.com.co/project: contenerizacion
    app.bancolombia.com.co/responsible: cde-plataformas-y-disponibilidad-ti
    eksctl.io/v1alpha2/nodegroup-name: k8s-AmazonLinux2023
  userData: |
    #!/bin/bash
    set -e
    get_imds_token() {
        curl -X PUT "http://169.254.169.254/latest/api/token" \
            -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" \
            --max-time 10 --retry 3
    }
    get_metadata() {
        local path=$1
        local token=$2
        curl -H "X-aws-ec2-metadata-token: $token" \
            "http://169.254.169.254/latest/meta-data/$path" \
            --max-time 10 --retry 3
    }
    detect_os() {
        if [ -f /etc/bottlerocket-release ]; then
            echo "bottlerocket"
        elif [ -f /etc/os-release ] && grep -q "Amazon Linux" /etc/os-release; then
            echo "al2023"
        fi
    }
    get_target_size_by_suffix() {
        local instance_type=$1
        local size_suffix=$(echo $instance_type | sed 's/.*\.//')
        case $size_suffix in
            4xlarge) echo 50 ;;
            6xlarge) echo 80 ;;
            8xlarge|9xlarge) echo 100 ;;
            *) echo 100 ;;
        esac
    }
    resize_ebs_for_instance() {
        local os_type=$(detect_os)
        local device
        case $os_type in
            bottlerocket)
                device="/dev/xvdb"
                ;;
            al2023)
                device="/dev/xvda"
                ;;
        esac
        local token=$(get_imds_token)
        if [ -z "$token" ]; then
            echo "Failed to get IMDSv2 token"
            return 1
        fi
        local instance_id=$(get_metadata "instance-id" "$token")
        local region=$(get_metadata "placement/region" "$token")
        local instance_type=$(get_metadata "instance-type" "$token")
        if [ -z "$instance_id" ] || [ -z "$region" ] || [ -z "$instance_type" ]; then
            echo "Failed to get required metadata"
            return 1
        fi
        local target_size=$(get_target_size_by_suffix "$instance_type")
        echo "OS: $os_type, Instance: $instance_type -> Target: ${target_size}GB"
        local volume_id=$(aws ec2 describe-instances --instance-ids $instance_id \
            --query 'Reservations[0].Instances[0].BlockDeviceMappings[?DeviceName==`'$device'`].Ebs.VolumeId' \
            --output text --region $region)
        if [ -z "$volume_id" ] || [ "$volume_id" = "None" ]; then
            echo "Error: Could not find volume for device $device"
            return 1
        fi
        local current_size=$(aws ec2 describe-volumes --volume-ids $volume_id \
            --query 'Volumes[0].Size' --output text --region $region)
        if [ "$current_size" -ge "$target_size" ]; then
            echo "Volume already correct size (${current_size}GB)"
            return 0
        fi
        echo "Resizing volume from ${current_size}GB to ${target_size}GB"
        aws ec2 modify-volume --volume-id $volume_id --size $target_size --region $region
        local timeout=300
        local elapsed=0
        local wait_time=2
        while [ $elapsed -lt $timeout ]; do
            local state=$(aws ec2 describe-volumes-modifications --volume-ids $volume_id \
                --query 'VolumesModifications[0].ModificationState' --output text --region $region)
            if [[ "$state" = "completed" || "$state" = "optimizing" ]]; then
                echo "Volume modification completed"
                break
            elif [ "$state" = "failed" ]; then
                echo "Volume modification failed"
                return 1
            fi
            sleep $wait_time
            elapsed=$((elapsed + wait_time))
            wait_time=$((wait_time * 2))
            [ $wait_time -gt 30 ] && wait_time=30
        done
        if [ $elapsed -ge $timeout ]; then
            echo "Timeout waiting for volume modification"
            return 1
        fi
        if [ "$os_type" = "al2023" ]; then
            growpart $device 1 || {
                echo "Failed to extend partition"
                return 1
            }
            local fs_type=$(lsblk -f ${device}1 | tail -1 | awk '{print $2}')
            case $fs_type in
                xfs)
                    xfs_growfs / || {
                        echo "Failed to resize XFS filesystem"
                        return 1
                    }
                    ;;
                ext4)
                    resize2fs ${device}1 || {
                        echo "Failed to resize ext4 filesystem"
                        return 1
                    }
                ;;
                *)
                    echo "Unsupported filesystem: $fs_type"
                    return 1
                    ;;
            esac
        fi
        echo "EBS resize completed successfully"
        return 0
    }
    if ! resize_ebs_for_instance; then
        echo "EBS resize failed"
    fi
    os_type=$(detect_os)
    if [ "$os_type" = "al2023" ]; then
        /usr/bin/nodeadm init
    fi